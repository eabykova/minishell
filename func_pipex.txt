---open---
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);

Используется для преобразования путя к файлу в fd-шник(небольшое неотрицательное число).
В результате успешного вызова проявляется новый открытый файл не зарделенный процессами (пока не
запустили fork())
Работает с флагами O_RDONLY (только чтение), O_WRONLY (только запись) или O_RDWR (чтение и запись)
Возвращает -1 при ошибке


---close---
#include <unistd.h>

int close(int fd);

Закрывает fd-шник, который после этого не ссылается ни на один файл и может использоваться
повторно
Возвращает 0 при успешном завершении, -1 при ошибке


---read---
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);

read пытается записать count байтов fd-шника в буфер, адрес которого начинается с *buf
Если count == 0, read возвращает это нулевое значение и заканчивает работу
При упешном завершении вызова возвращает кол-во прочитанных байтов, при ошибке -1


---write---
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);

записывает до count байтов из буфера buf в файл, на который ссылается fd-шник
В случае успеха возвращает кол-во прочитанных байтов, 0, если count == 0 и fd-шник ссылается
на обычный файл


---malloc, free---
#include <stdlib.h>

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);


calloc() распределяет память для массива размером nmemb, каждый элемент которого равен size
байтов, и возвращает указатель на распределенную память. Память при этом "очищается".
malloc() распределяет size байтов и возвращает указатель на распределенную память. Память
при этом не "очищается".

free() освобождает место в памяти, на которое указывает ptr, возвращенный, по-видимому,
предшествующим вызовом функций malloc(), calloc() или realloc(). Иначе (или если уже
вызывался free(ptr)) дальнейший ход событий непредсказуем. Если ptr равен NULL, то не
выполняется никаких действий.

realloc() меняет размер блока памяти, на который указывает ptr, на размер, равный size байтов.
Содержание будет неизменным в пределах наименьшего из старых и новых размеров, а новая
распределенная память будет неинициализирована. Если ptr равно NULL, то данный вызов
эквивалентен malloc(size); если размер равен нулю, то данный вызов эквивалентен free(ptr).
Если только ptr не равен NULL, он,
по-видимому, возвращен более ранним вызовом malloc(), calloc() или realloc().

Для calloc() и malloc() возвращаемые значения являются указателем на память, которая должным
образом распределена для каждого типа переменных; или NULL, если запрос завершился некорректно.
free() не возвращает значений.

realloc() возвращает указатель на память, которая должным образом повторно распределена
для каждого типа переменных и может отличаться от ptr, или возвращает NULL, если запрос
завершился с ошибкой. Если size был равен нулю, то возвращается либо NULL, либо указатель,
который может быть передан free(). Если realloc() не выполнена,
то блок памяти остается нетронутым: он не "очищается" и не перемещается.


---perror---
#include <stdio.h>
void perror(const char *s);

#include <errno.h>

const char *sys_errlist[];
int sys_nerr;

выводит сообщение о системной ошибке в понятном для человека виде
выводит в стандартный поток ошибки сообщения, описывая ошибку, произошедшую при последнем
системном вызове или вызове библиотечной функции


---strerror---
#include <string.h>

char *strerror(int errnum);
int strerror_r(int errnum, char *buf, size_t n);

возвращает строку, описывающую код ошибки, переданный в аргументе errnum
Приложение не должно изменять строку. Строка может измениться при последующем
вызовом perror() или strerror(). В библиотеке нет функций изменяющих эту строку

Функция strerror_r() аналогична strerror(), но безопасна с точки зрения подпроцессов (threads).
Она возвращает строку в буфере buf, предоставленном пользователем и имеющим длину n.

Функция strerror() возвращает соответсвующее описание ошибки или сообщение о том,
что ошибка неизвестна. Значение errno при удачном вызове не меняется,
а при ошибке устанавливается в ненулевое значение. Функция strerror_r()
возвращает 0 при успешном завершении и -1 при ошибке, устанавливая при этом errno.


---access---
#include <unistd.h>

int access(const char *pathname, int mode);

проверяет, имеет ли процесс права на чтение или запись, или же просто проверяет,
существует ли файл (или другой объект файловой системы), с именем pathname.
Если pathname является символьной ссылкой, то проверяются права доступа к файлу,
на который она ссылается.

mode -- это маска, состоящая из одного или более флагов R_OK(существование файла),
W_OK(возможность чтения), X_OK(возможность записи) и F_OK(возможность выполнения)
Проверяются только биты прав доступа, а не тип файла или его содержимое
В случае успеха возвращает 0, при ошибке -1


---dup, dup2---
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);

dup и dup2 создают копию файлового дескриптора oldfd.
Старый и новый дескрипторы можно использовать друг вместо друга.
Они имеют общие блокировки, указатель позиции в файле и флаги.
dup использует самый маленький свободный номер дескриптора.
dup2 делает newfd копией oldfd, закрывая newfd, если требуется.

возвращают fd-шник, либо -1 при ошибке


---execve---
#include <unistd.h>
int execve(const char *filename, char *const argv [], char *const envp[]);

выполняет программу, заданную параметром filename. Программа должна быть или двоичным
исполняемым файлом, или скриптом, начинающимся со строки вида "#! интерпретатор [аргументы]".
В последнем случае интерпретатор -- это правильный путь к исполняемому файлу, который
не является скриптом; этот файл будет выполнен как интерпретатор [arg] filename.

envp -- это массив строк в формате key=value, которые передаются новой программе в
качестве окружения (environment), завершается NULL-поинтером
execve() не возвращает управление при успешном выполнении, а код, данные, bss и стек
вызвавшего процесса перезаписываются кодом, данными и стеком загруженной программы.
Новая программа также наследует от вызвавшего процесса его идентификатор и открытые
файловые дескрипторы, на которых не было флага закрыть-при-exec (close-on-exec, COE).
Сигналы, ожидающие обработки, удаляются. Переопределённые обработчики сигналов возвращаются
в значение по умолчанию


---exit---
#include <stdlib.h>

void exit(int status);

приводит к обычному завершению программы, и величина status & 0377 возвращается процессу-родителю
Файлы, созданные функцией tmpfile() удаляются.
Не возвращает значений


---fork---
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);

создает процесс-потомок, который отличается от родительского только значениями PID
и PPID, а также тем фактом, что счетчики использования ресурсов установлены в 0.
Блокировки файлов и сигналы, ожидающие обработки, не наследуются

При успешном завершении родителю возвращается PID процесса-потомка, а процессу-потомку
возвращается 0. При неудаче родительскому процессу возвращается -1,
процесс-потомок не создается, а значение errno устанавливается должным образом.


---pipe---
#include <unistd.h>
int pipe(int filedes[2]);

pipe создает пару файловых описателей, указывающих на запись inode именованного канала,
и помещает их в массив, на который указывает filedes. filedes[0] предназначен для чтения,
а filedes[1] предназначен для записи

При удачном завершении вызова возвращаемое значение равно нулю. При ошибке возвращается -1


---unlink---
#include <unistd.h>
int unlink(const char *pathname);

unlink удаляет имя из файловой системы. Если это имя было последней ссылкой на файл и больше
нет процессов, которые держат этот файл открытым, данный файл удаляется и место,
которое он занимает освобождается для дальнейшего использования

Если имя было посленей ссылкой на файл, но какие-либо процессы всё ещё держат этот файл открым,
файл будет оставлен пока последний файловый дескриптор, указывающий на него, не будет закрыт

В случае успеха возвращается 0 при ошибке -1


---wait, waitpid---
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);

Функция wait приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс
не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует
вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции уже завершился
(так называемый "зомби" ("zombie")), то функция немедленно возвращается. Системные ресурсы,
связанные с дочерним процессом, освобождаются. Функция waitpid приостанавливает выполнение
текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит
выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует
вызвать функцию-обработчик. Если указанный дочерний процесс к моменту вызова функции
уже завершился (так называемый "зомби"), то функция немедленно возвращается

Возвращает идентификатор дочернего процесса, который завершил выполнение, или 0, если использовался
WNOHANG и ни один дочерний процесс пока еще недоступен, или -1 в случае ошибки